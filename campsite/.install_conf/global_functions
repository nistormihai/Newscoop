#!/bin/bash

###########################################################
## General purpose functions
###########################################################

# FUNCTION: in_list
# Description: check if the first parameter is in given list (rest of the parameters)
# Parameters:
#	$1 - element to check
#	$2... - list elements
# Variables set:
#	element_index - position in list (starts from 1)
in_list()
{
search_element=$1 && [ "$search_element" = "" ] && return 1
shift 1
[ "$1" = "" ] && return 1
element_index=1
for element in $*; do
    [ "$search_element" = "$element" ] && return 0
    element_index=`expr $element_index + 1`
done
element_index=0
return 1
}
# END OF in_list

# FUNCTION: add_to_list_var
# Description: add element to list contained in given variable
# Parameters:
#	$1 - element to add
#	$2 - list variable name
# Variables set:
#	list variable
add_to_list_var()
{
add_element=$1
[ "$add_element" = "" ] && return 0
list_var=$2
[ "$list_var" = "" ] && return 0
in_list $add_element ${!list_var} && return 0
export ${list_var}="${!list_var} $add_element"
return 0
}
# END OF add_to_list_var

# FUNCTION: rm_from_list_var
# Description: remove element from list contained in given variable
# Parameters:
#	$1 - element to remove
#	$2 - list variable name
# Variables set:
#	list variable
rm_from_list_var()
{
rm_element=$1
[ "$rm_element" = "" ] && return 0
list_var=$2
[ "$list_var" = "" ] && return 0
! in_list $rm_element ${!list_var} && return 0
lst=${!list_var}
export $list_var=""
for el in $lst; do
    [ "$el" != "$rm_element" ] && add_to_list_var $el $list_var
done
return 0
}
# END OF rm_from_list_var

# FUNCTION: choice_yn
# Description: read a choice from standard input (Y/y -yes or N/n - no)
# Parameters:
#	$1 - message to print to screen
#	$2 - default choice
# Variables set:
#	choice - the selected choice (Y/N)
choice_yn()
{
choice_message=$1
case $2 in
y | Y)
    default_choice="Y" ;;
n | N)
    default_choice="N" ;;
*)
    default_choice="" ;;
esac
while true; do
    echo -n -e "$choice_message (Y/N)"
    if [ "$default_choice" != "" ]; then
    	echo -n " [$default_choice]"
    fi
    echo -n ": "
    read -r choice
    if [ "$default_choice" != "" ] && [ "$choice" = "" ]; then
    	choice=$default_choice
    fi
    case $choice in
    y | Y)
	export choice=Y
	return 0 ;;
    n | N)
	export choice=N
	return 1 ;;
    *)
	echo -n -e "\rInvalid choice $choice. " ;;
    esac
done
return 0
}
# END OF choice_yn

# FUNCTION: cut_last_dirs
# Description: cut last specified number of directories from path
# Parameters:
#	$1 - path
#	$2 - number of directories to cut from path
# Variables set:
#	new_path - resulted path
cut_last_dirs()
{
path=$1
nr=1
[ "$2" != "" ] && nr=$2
dirs=""
i=1
abs_path=false
while true; do
    dir=`echo $path | cut -f $i -d "/"`
    [ "$dir" = "" ] && [ $i -eq 1 ] && abs_path=true
    [ "$dir" = "" ] && [ $i -gt 1 ] && break
    dirs="$dirs $dir"
    i=`expr $i + 1`
done
i=`expr $i - $nr`
$abs_path && i=`expr $i - 1`
j=1
new_path=""
for d in $dirs; do
     [ $j -eq 1 ] && $abs_path && new_path="/"
     [ $j -eq 1 ] && new_path="$new_path$d"
     [ $i -gt $j ] && [ $j -gt 1 ] && new_path="${new_path}/$d"
     j=`expr $j + 1`
done
echo $new_path
return 0
}
# END OF cut_last_dirs

# FUNCTION: list_item
# Description: returns an intem from a list of strings
# Parameters:
#	$1 - item number
#	$2,$3... - list of items
# Variables set: none
list_item()
{
i=$1
shift 1
for true; do
    i=`expr $i - 1`
    if [ $i -eq 0 ]; then
	break;
    fi
    shift 1
done
echo $1
return 0
}
# END OF list_item

# FUNCTION: read_string
# Description: read a string from standard input
# Parameters:
#	$1 - name of variable to read string into
#	$2 - default value
#	$3 - explanation
# Variables set:
#	variable supplied as first parameter - set to input value
read_string()
{
echo -n "Enter $1"
[ "$3" != "" ] && echo -n " ($3)"
[ "$2" != "" ] && echo -n " [$2]"
echo -n ": "
read -r val
if [ "$val" = "" ]; then
    val=$2
fi
export $1="$val"
return 0
}
# END OF read_string

# FUNCTION: read_path_with_test
# Description: read a path from standard input and test if it exists
# Parameters:
#	$1 - name of variable to read path into
#	--file - next parameter is a file to test for in the read path
#	--default - next parameter is the default value
#	--exp - next parameter is supplemental explanation
# Variables set: none
read_path_with_test()
{
what="$1"
file=""
default=""
explanation=""
shift 1
while [ "$1" != "" ]; do
    [ "$1" = "--file" ] && file="$2" && shift 2
    [ "$1" = "--default" ] && default="$2" && shift 2
    [ "$1" = "--exp" ] && explanation="$2" && shift 2
done
while true; do
    read_string "$what" "$default" "$explanation"
    if [ ! -d ${!what} ] || ( [ ! -f ${!what}/$file ] && [ "$file" != "" ] ); then
	choice_yn "Invalid $what. Retry?" y
	if [ "$choice" = "N" ]; then
	    return 1
	fi
    else
	break
    fi
done
return 0
}
# END OF read_path_with_test

# FUNCTION: path dirs
# Description: writes path directories to standard output
# Parameters:
#	$1 - path
path_dirs()
{
path=$1
echo "$path" | grep ":" &> /dev/null
[ $? -ne 0 ] && echo $path && return 0
i=1
while true; do
    dir=`echo $path | cut -f $i -d ":"`
    [ "$dir" = "" ] && break
    echo -n " $dir"
    i=`expr $i + 1`
done
return 0
}
# END OF path dirs

# FUNCTION: check4_file
# Description: check if file exists
# Parameters:
#	--executable - file must be executable
#	--link - file must be link
#	--path <path> - search for file in given path
# Variables set:
#	output - error message (if any)
#	file_path - path of searched file (if file name contains no absolute path)
check4_file()
{
file_test=""
file_path=""
file_name=""
search_path=""
old_path=$PATH
output=""
for true; do
    [ "$1" = "" ] && break
    case $1 in
    --path) shift 1; search_path=$1 ;;
    --file) [ "$file_test" = "" ] && file_test="-f" ;;
    --directory) file_test="-d" ;;
    --link) file_test="-l" ;;
    --executable) [ "$file_test" = "" ] && file_test="-x" ;;
    *) file_name=$1 ;;
    esac
    shift 1
done
[ "$file_name" = "" ] && echo "File not specified" && return 1
[ "$file_test" = "" ] && file_test="-f"
case $file_test in
-f) file_type="file" ;;
-d) file_type-"directory" ;;
-x) file_type="executable" ;;
-l) file_type="link" ;;
esac
absolute_path=false
file_name_first_char="${file_name:0:1}"
[ "$file_name_first_char" = "/" ] && absolute_path=true
if $absolute_path; then
    [ $file_test "$file_name" ] && file_path=$file_name && return 0
    output="$file_name is not a $file_type" && echo $output
    return 1
else
    result=0
    if [ "$file_type" = "executable" ]; then
	export PATH="$PATH:/bin:/usr/bin:/usr/local/bin"
	if [ "$WHICH" = "" ]; then
	    for p in /bin/which /usr/bin/which /usr/local/bin/which; do
		[ -x $"$p" ] && WHICH=$p && break
	    done
	fi
	[ "$WHICH" = "" ] && output="could not find which binary" && echo $output && return 1
	[ "$search_path" != "" ] && export PATH=$search_path
	file_path=`$WHICH "$file_name" 2> /dev/null`
	result=$?
	[ "$search_path" != "" ] && export PATH=$old_path
    else
	if [ "$search_path" = "" ]; then
	    file_path=`locate "$file_name" | grep -w "$file_name" 2> /dev/null`
            result=$?
	else
	    for dir in `path_dirs $search_path`; do
		[ $file_test "${dir}/${file_name}" ] && file_path="${dir}/${file_name}" && return 0
	    done
	    result=1
	fi
    fi
    if [ $result -ne 0 ]; then
	output="$file_type $file_name not found in $search_path" && echo $output
	return 1
    fi
fi
return 0
}
# END OF check4_file

# FUNCTION: check4_symbol_and_prototype
# Description: check for the existence of a symbol in a library, and also
#              for a corresponding prototype in a header
# Parameters:
#	$1	- library to look in
#	$2	- path(s) to library
#	$3	- header to look in
#	$4	- path(s) to header
#	$5	- symbol to find
#
# Variables set:
#	output - error message (if any)
check4_symbol_and_prototype()
{
if [ "$1" = "" ] || [ "$2" = "" ] || [ "$3" = "" ] || [ "$4" = "" ] || [ "$5" = "" ]; then
	echo "Invalid parameters in check4_symbol_and_prototype()"
	return 1
fi
check4_file $1 --file --path $2
if [ $? -eq 0 ]; then
	res=1
	libs=`strings $file_path | grep ^GROUP | cut -f 2 -d "(" | cut -f 1 -d ")"`
	if [ "$libs" = "" ]; then
		found=`strings $file_path | grep -w $5 2>/dev/null`
		res=$?
	else
		for l in $libs; do
			found=`strings $l | grep -w $5 2>/dev/null`
			[ $? -eq 0 ] && res=0
		done
	fi
	if [ $res -eq 0 ]; then
		check4_file $3 --file --path $4
		res=$?
		if [ $res -eq 0 ]; then
			found=`grep -w $5 $file_path 2>/dev/null`
			res=$?
			if [ $res -eq 0 ]; then
				return 0
			fi
		else
			echo $msg
		fi
	fi
fi
return 1
}
# END OF check4_symbol_and_prototype
