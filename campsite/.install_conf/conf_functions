#!/bin/sh

. ${INSTALL_CONF}/check4_functions

###########################################################
## Functions for manipulating configuration variables
###########################################################

# FUNCTION: save_var
# Description: save the values of given variables into a file
# Parameters:
#	$1... - variable name
# Variables set: none
save_var()
{
rm -f ./.env_vars
while [ "$1" != "" ]; do
    var_name=$1
    echo "$var_name=${!var_name}" >> ./.env_vars
    shift 1
done
}
# END OF save_var

# FUNCTION: var_not_modified
# Description: check if saved variables modified their value
# Parameters: none
# Variables set: none
var_not_modified()
{
[ ! -f ./.env_vars ] && return 1
var_list=`cut -f 1 -d '=' ./.env_vars`
for v in $var_list; do
    saved_value=`grep -w $v ./.env_vars | cut -f 2 -d '='`
    [ "${!v}" != "$saved_value" ] && return 1
done
return 0
}
# END OF var_not_modified

# FUNCTION: is_configured
# Description: check if module is already configured
# Parameters:
#	$1 - module name
# Variables set: none
is_configured()
{
[ "$1" = "" ] && return 0
in_list $1 $CONFIGURED_MODULES && return 0
return 1
}
# END OF is_configured

# FUNCTION: set_configured
# Description: set module as configured
# Parameters:
#	$1 - module name
# Variables set:
#	CONFIGURED_MODULES
set_configured()
{
[ "$1" = "" ] && return 0
in_list $1 $CONFIGURED_MODULES && return 0
export CONFIGURED_MODULES="$CONFIGURED_MODULES $1"
return 0
}
# END OF set_configured

# FUNCTION: set_not_configured
# Description: set module as not configured
# Parameters:
#	$1 - module name
# Variables set:
#	CONFIGURED_MODULES
set_not_configured()
{
[ "$1" = "" ] && return 0
! in_list $1 $CONFIGURED_MODULES && return 0
rm_from_list_var $1 CONFIGURED_MODULES
return 0
}
# END OF set_not_configured

# FUNCTION: unset_env_vars
# Description: unset environment variables used for installation
# Parameters: none
# Variables set: none
unset_env_vars()
{
unset SELECTED_MODULES
unset IMPLEMENTATION_PARTS
unset SUPPLEMENTAL_PARTS
unset CAMPSITE_VERSION
unset INSTALL_CONF
unset CAMPSITE_PACKAGE_DIR
unset MYSQL_CONNECT
unset SMTP_WRAPPER
unset CAMPSITE_REGISTER
unset INSTALL_LOG
unset CHECKED_DEPENDENCIES
unset CHECKED_MODULES
unset CONFIGURED_MODULES
unset INSTALL_CONFIGURED
unset PACKAGE_TYPE
unset PREPARED_MOD_ENV
modules_conf --unset
install_conf --unset
}
# END OF unset_env_vars

###########################################################
## Functions for reading configuration from files
###########################################################

# FUNCTION: dependent_on
# Description: prints the list of modules that depend on given module
# Parameters:
#	$1 - module to print the list for
# Variables set: none
dependent_on()
{
validate_module $1
[ $? -ne 0 ] && return 1
grep -w "@$1" ${INSTALL_CONF}/.modules.dep | cut -f 1 -d ":"
return $?
}
# END OF dependent_on

# FUNCTION: depends_on
# Description: prints the list of modules that given module depends on
# Parameters:
#	$1 - module to print the list for
# Variables set: none
depends_on()
{
validate_module $1
[ $? -ne 0 ] && return 1
do_deps=`grep -w "^$1" ${INSTALL_CONF}/.modules.dep | cut -f 2 -d ":"`
[ $? -ne 0 ] && return 1
for do_d in $do_deps; do
    if [ "${do_d:0:1}" = "@" ]; then
	echo ${do_d:1}
    fi
done
return 0
}
# END OF depends_on

# FUNCTION: preconf_modules
# Description: prints the list of modules that must be configured
#	before given module is configured
# Parameters:
#	$1 - module to print the list for
# Variables set: none
preconf_modules()
{
validate_module $1
[ $? -ne 0 ] && return 1
grep -w "^$1" ${INSTALL_CONF}/.modules.dep | cut -f 3 -d ":"
return $?
}
# END OF preconf_modules

# FUNCTION: read_module_deps
# Description: prints the list of dependencies for given module
# Parameters:
#	$1 - modules to print dependencies for
# Variables set: none
read_module_deps()
{
validate_module $1
[ $? -ne 0 ] && return 1
fields="4"
[ "$PACKAGE_TYPE" = "source" ] && fields="${fields} 5"
found_mod_deps=""
mod_deps=""
for fld in $fields; do
    found_mod_deps=`grep -h -w "^$1" ${INSTALL_CONF}/.modules.dep | cut -f $fld -d ":"`
    [ $? -ne 0 ] && echo $found_mod_deps && return 1
    for mod_dep in $found_mod_deps; do mod_deps="$mod_deps $mod_dep"; done
done
echo $mod_deps
return 0
}
# END OF read_module_deps

# FUNCTION: read_install_deps
# Description: prints the list of install dependencies
# Parameters: none
# Variables set: none
read_install_deps()
{
cat ${INSTALL_CONF}/.inst.dep
[ $? -ne 0 ] && return 1
return 0
}
# END OF read_install_deps

# FUNCTION: modules_list
# Description: returns the list of campsite modules
# Parameters:
#	$1, $2... - list of selected modules
# Variables set:
#	modules - list of modules
modules_list()
{
modules=""
while [ "$1" != "" ]; do
    modules="$modules $1"
    shift 1
done
if [ "$modules" = "" ]; then
    modules=`cat ${INSTALL_CONF}/.modules.dep | cut -f 1 -d ":"`
fi
echo $modules
return 0
}
# END OF modules_list

# FUNCTION: modules_desc
# Description: prints the description of selected/campsite modules
# Parameters:
#	$1, $2... - list of selected modules
# Variables set:
#	modules - list of modules
modules_desc()
{
modules=`modules_list $*`
md=`cat ${INSTALL_CONF}/.modules.desc`
state=init
for w in $md; do
    case $state in
    init)
	mod_name=""
	mod_desc=""
	if [ "$w" = "[" ]; then
	    state=read_name
	fi ;;
    read_name)
	mod_name=$w
	state=read_desc ;;
    read_desc)
	if [ "$w" = "#" ]; then
	    [ "$mod_desc" != "" ] && mod_desc="$mod_desc \n"
	elif [ "$w" = "]" ]; then
	    echo $modules | grep $mod_name &> /dev/null
	    if [ $? -eq 0 ]; then
	        echo -e "\n$mod_name\n$mod_desc"
	    fi
	    state=init
	else
	    mod_desc="$mod_desc $w"
	fi ;;
    *)
	echo "Internal error"
	exit 1 ;;
    esac
done
return 0
}
# END OF modules_desc

# FUNCTION: modules_conf
# Description: prints the configuration of selected/campsite modules
# Parameters:
#	$1=--set|--unset - set/unset module configuration variables
#	$1, $2... - list of selected modules
# Variables set:
#	modules - modules list
#	configurable_modules - configurable modules
#	module configuration variables (only if --set parameter is received)
modules_conf()
{
action="print"
[ "$1" = "--set" ] && action="set" && shift 1
[ "$1" = "--unset" ] && action="unset" && shift 1
configurable_modules=""
modules=`modules_list $*`
mc=`cat ${INSTALL_CONF}/.modules.conf`
state=init_mod
for w in $mc; do
    case $state in
    init_mod)
	mod_name=""
	print_conf=false
	attr_list=""
	attr_desc=""
	attr_name=""
	if [ "$w" = "[" ]; then
	    state=read_mod_name
	fi ;;
    read_mod_name)
	mod_name=$w
	configurable_modules="$configurable_modules $mod_name"
	echo $modules | grep $mod_name &> /dev/null
	[ $? -eq 0 ] && print_conf=true
	state=read_attr_name ;;
    read_attr_name)
	if [ "$w" = "{" ]; then
	    state=read_attr_desc
	elif [ "$w" = "]" ]; then
	    state=init_mod
	    [ "$action" = "print" ] && [ "$print_conf" = "true" ] && echo -e $attr_list
	else
	    [ "$attr_list" != "" ] && attr_list="$attr_list\n"
	    attr_name=$w
	    attr_list="$attr_list${mod_name}_$attr_name="
	    attr_val=""
	    state=read_attr_val
	fi ;;
    read_attr_val)
	attr_desc=""
	if [ "$w" = "{" ]; then
	    attr_list="$attr_list$attr_val"
	    [ "$action" = "set" ] && [ "$print_conf" = "true" ] && export ${mod_name}_$attr_name="`echo $attr_val`"
	    [ "$action" = "unset" ] && [ "$print_conf" = "true" ] && unset ${mod_name}_$attr_name
	    state=read_attr_desc
	else
	    [ "$attr_val" != "" ] && attr_val="$attr_val $w"
	    [ "$attr_val" = "" ] && attr_val="$w"
	fi
	;;
    read_attr_desc)
	if [ "$w" = "}" ]; then
	    attr_list="$attr_list # $attr_desc"
	    state=read_attr_name
	else
	    attr_desc="$attr_desc $w"
	fi
	;;
    *)
	echo "Internal error (invalid state $state)"
	exit 1 ;;
    esac
done
return 0
}
# END OF modules_conf

# FUNCTION: selected_modules
# Description: prints the list of selected modules
# Parameters: none
# Variables set: none
selected_modules()
{
cat ${INSTALL_CONF}/.inst.modules
return 0
}
# END OF selected_modules

# FUNCTION: install_conf
# Description: prints the install configuration
# Parameters:
#	$1=--set|--unset - set/unset install configuration variables
# Variables set:
#	install configuration variables (only if --set parameter is received)
install_conf()
{
action="print"
[ "$1" = "--set" ] && action="set" && shift 1
[ "$1" = "--unset" ] && action="unset" && shift 1
mc=`cat ${INSTALL_CONF}/.inst.conf | grep -v ^#`
attr_list=""
attr_desc=""
attr_name=""
state=init
for w in $mc; do
    case $state in
    init)
	if [ "$w" = "[" ]; then
	    state=read_attr_name
	fi ;;
    read_attr_name)
	if [ "$w" = "{" ]; then
	    state=read_attr_desc
	elif [ "$w" = "]" ]; then
	    state=end
	else
	    [ "$attr_list" != "" ] && attr_list="$attr_list\n"
	    attr_name=$w
	    attr_list="$attr_list$attr_name="
	    attr_val=""
	    state=read_attr_val
	fi ;;
    read_attr_val)
	attr_desc=""
	if [ "$w" = "{" ]; then
	    [ "$action" = "set" ] && export $attr_name="`echo $attr_val`"
	    [ "$action" = "unset" ] && unset $attr_name
	    attr_list="$attr_list$attr_val"
	    state=read_attr_desc
	elif [ "$w" = "]" ]; then
	    attr_list="$attr_list$attr_val"
	    state=end
	else
	    [ "$attr_val" != "" ] && attr_val="$attr_val $w"
	    [ "$attr_val" = "" ] && attr_val="$w"
	fi
	;;
    read_attr_desc)
	if [ "$w" = "}" ]; then
	    attr_list="$attr_list # $attr_desc"
	    state=read_attr_name
	elif [ "$w" = "]" ]; then
	    state=end
	else
	    attr_desc="$attr_desc $w"
	fi
	;;
    end)
	;;
    *)
	echo "Internal error (invalid state $state)"
	exit 1 ;;
    esac
done
[ "$action" = "print" ] && echo -e $attr_list
return 0
}
# END OF install_conf

###########################################################
## Functions for environment preparation
###########################################################

# FUNCTION: prepare_DATABASE_env
# Description: prepare the environment for DATABASE module
# Parameters: none
# Variables set:
#	MYSQL_CONNECT - mysql_connect binary full path
prepare_DATABASE_env()
{
in_list DATABASE $PREPARED_MOD_ENV && return 0
output_err="Error preparing environment for DATABASE module."
echo -e "*** Preparing DATABASE environment..."
mysql_connect=${CAMPSITE_PACKAGE_DIR}/supplemental/mysql_connect/mysql_connect/mysql_connect
if [ "$PACKAGE_TYPE" = "binary" ]; then
    check4_file $mysql_connect --executable
    [ $? -ne 0 ] && echo $output_err && return 1
else
    pushd `pwd` &> /dev/null
    cd ${CAMPSITE_PACKAGE_DIR}/supplemental/mysql_connect
    ./configure && make && check4_file $mysql_connect --executable
    result=$?
    popd &> /dev/null
    [ $result -ne 0 ] && echo $output_err && return 1
fi
export MYSQL_CONNECT=$mysql_connect
add_to_list_var DATABASE PREPARED_MOD_ENV
echo "DATABASE environment OK"
return 0
}
# END OF prepare_DATABASE_env

# FUNCTION: prepare_PARSER_env
# Description: prepare the environment for PARSER module
# Parameters: none
# Variables set: none
prepare_PARSER_env()
{
in_list PARSER $PREPARED_MOD_ENV && return 0
output_err="Error preparing environment for PARSER module."
echo -e "*** Preparing PARSER environment...OK"
add_to_list_var PARSER PREPARED_MOD_ENV
return 0
}
# END OF prepare_PARSER_env

# FUNCTION: prepare_EVENT_HANDLERS_env
# Description: prepare the environment for EVENT_HANDLERS module
# Parameters: none
# Variables set:
#	SMTP_WRAPPER - smtp_wrapper binary full path
prepare_EVENT_HANDLERS_env()
{
in_list EVENT_HANDLERS $PREPARED_MOD_ENV && return 0
output_err="Error preparing environment for EVENT_HANDLERS module."
echo -e "*** Preparing EVENT_HANDLERS environment..."
smtp_wrapper=${CAMPSITE_PACKAGE_DIR}/implementation/mailnotify/smtp_wrapper/smtp_wrapper/smtp_wrapper
if [ "$PACKAGE_TYPE" = "binary" ]; then
    check4_file $smtp_wrapper --executable
    [ $? -ne 0 ] && echo $output_err && return 1
else
    pushd `pwd` &> /dev/null
    cd ${CAMPSITE_PACKAGE_DIR}/implementation/mailnotify/smtp_wrapper
    ./configure && make && check4_file $smtp_wrapper --executable
    result=$?
    popd &> /dev/null
    [ $result -ne 0 ] && echo $output_err && return 1
fi
export SMTP_WRAPPER=$smtp_wrapper
add_to_list_var EVENT_HANDLERS PREPARED_MOD_ENV
echo "EVENT_HANDLERS environment OK"
return 0
}
# END OF prepare_EVENT_HANDLERS_env

# FUNCTION: prepare_SEARCH_ENGINE_env
# Description: prepare the environment for SEARCH_ENGINE module
# Parameters: none
# Variables set: none
prepare_SEARCH_ENGINE_env()
{
in_list SEARCH_ENGINE $PREPARED_MOD_ENV && return 0
output_err="Error preparing environment for SEARCH_ENGINE module."
echo -e "*** Preparing SEARCH_ENGINE environment...OK"
add_to_list_var SEARCH_ENGINE PREPARED_MOD_ENV
return 0
}
# END OF prepare_SEARCH_ENGINE_env

# FUNCTION: prepare_ADMIN_INTERFACE_env
# Description: prepare the environment for  module
# Parameters: none
# Variables set: none
prepare_ADMIN_INTERFACE_env()
{
in_list ADMIN_INTERFACE $PREPARED_MOD_ENV && return 0
output_err="Error preparing environment for ADMIN_INTERFACE module."
echo -e "*** Preparing ADMIN_INTERFACE environment...OK"
add_to_list_var ADMIN_INTERFACE PREPARED_MOD_ENV
return 0
}
# END OF prepare_ADMIN_INTERFACE_env

# FUNCTION: prepare_install_env
# Description: prepare the install environment
# Parameters: none
# Variables set:
prepare_install_env()
{
output_err="Error preparing install environment."
echo -e -n "*** Preparing install environment..."
export CAMPSITE_REGISTER=/etc/campsite.reg
export CHECKED_DEPENDENCIES=""
export CHECKED_MODULES=""
export CONFIGURED_MODULES=""
export INSTALL_CONFIGURED="no"
export PREPARED_MOD_ENV=""
selected_modules=`selected_modules`
[ $? -ne 0 ] && echo "Error reading selected modules" && exit 1
export SELECTED_MODULES=$selected_modules
export IMPLEMENTATION_PARTS=""
export SUPPLEMENTAL_PARTS=""
for mod in $SELECTED_MODULES; do
    set_module_parts $mod
    [ $? -ne 0 ] && echo $output_err && return 1
done
set_need_config_modules
echo "OK"
return 0
}
# END OF prepare_install_env

# FUNCTION: set_module_parts
# Description: add module parts to IMPLEMENTATION_PARTS and SUPPLEMENTAL_PARTS variables
# Parameters: none
# Variables set:
#	IMPLEMENTATION_PARTS and SUPPLEMENTAL_PARTS
set_module_parts()
{
output=`validate_module $1`
[ $? -ne 0 ] && echo $output && return 1
parts=`grep -w "^$1" ${INSTALL_CONF}/.modules.dep | cut -f 2 -d ":"`
[ $? -ne 0 ] && echo $parts && return 1
for part in $parts; do
    first_char=${part:0:1}
    if [ "$first_char" != "@" ]; then
	part_type=`echo $part | cut -f 1 -d "/"`
	part_name=`echo $part | cut -f 2 -d "/"`
	[ "$part_type" = "implementation" ] && add_to_list_var $part_name IMPLEMENTATION_PARTS
	[ "$part_type" = "supplemental" ] && add_to_list_var $part_name SUPPLEMENTAL_PARTS
    fi
done
return 0
}
# END OF set_module_parts

# FUNCTION: set_need_config_modules
# Description: set NEED_CONFIG_MODULES variable (contains modules that need to
#	be configured)
# Parameters: none
# Variables set:
#	NEED_CONFIG_MODULES
set_need_config_modules()
{
modules_conf --set
NEED_CONFIG_MODULES=""
for ncm_mod in $SELECTED_MODULES; do
    ncm_preconf_mod=`preconf_modules $ncm_mod`
    for ncm_pmod in $ncm_preconf_mod; do
	in_list $ncm_mod $configurable_modules && add_to_list_var $ncm_pmod NEED_CONFIG_MODULES
    done
    in_list $ncm_mod $configurable_modules && add_to_list_var $ncm_mod NEED_CONFIG_MODULES
done
export NEED_CONFIG_MODULES
}
# END OF set_need_config_modules

###########################################################
## Functions for validation of modules/installation
###########################################################

# FUNCTION: validate_module
# Description: check if module name is valid
# Parameters:
#	$1 - module name
#	$2=--config - check if module is configurable
# Variables set: none
validate_module()
{
module=$1
[ "$module" = "--config" ] && module=""
shift 1
if [ "$module" = "" ]; then
    echo "Specify a module"
    return 1
fi
grep -w -e "$module" ${INSTALL_CONF}/.modules.dep &> /dev/null
if [ $? -ne 0 ]; then
    echo "Invalid module name $module"
    return 1
fi
if [ "$1" != "--config" ]; then
    return 0
fi
grep -w -e "$module" ${INSTALL_CONF}/.modules.conf &> /dev/null
if [ $? -ne 0 ]; then
    echo "Module $module is not configurable"
    return 1
fi
return 0
}
# END OF validate_module

# FUNCTION: check_module_deps
# Description: check if given module dependencies are satisfied
# Parameters:
#	$1 - module name
# Variables set: none
check_module_deps()
{
validate_module $1
[ $? -ne 0 ] && return 1
echo -n "Checking $1 module dependencies..."
mod_deps=`read_module_deps $1`
[ $? -ne 0 ] && echo -e "ERROR\n$mod_deps" && return 1
for mod_dep in $mod_deps; do
    check4_${mod_dep} $2
    [ $? -ne 0 ] && return 1
done
echo "OK"
return 0
}
# END OF check_module_deps

# FUNCTION: check_install_deps
# Description: check if install dependencies are satisfied
# Parameters: none
# Variables set: none
check_install_deps()
{
echo -n "Checking install dependencies..."
inst_deps=`read_install_deps $1`
[ $? -ne 0 ] && echo "$inst_deps" && return 1
for inst_dep in $inst_deps; do
    check4_${inst_dep} $1
    [ $? -ne 0 ] && return 1
done
echo "OK"
return 0
}
# END OF check_install_deps

# FUNCTION: check_DATABASE_config
# Description: check if DATABASE module configuration is valid
# Parameters:
#	$1=--upgrade - configure for upgrade
# Variables set:
#	mysql_version - mysql server version
#	output - output error message (if any)
check_DATABASE_config()
{
dc_upgrade=false
while [ "$1" != "" ]; do
    case $1 in
    --upgrade) dc_upgrade=true ;;
    esac
    shift 1
done
in_list DATABASE $CHECKED_MODULES && return 0
if [ "$DATABASE_PASSWORD" != "" ]; then
    password="-p$DATABASE_PASSWORD"
else
    password=""
fi
echo -n "Testing database configuration..."
database=""
grep -w DATABASE ${INSTALL_CONF}/.inst.modules &> /dev/null
[ $? -ne 0 ] && database="-d $DATABASE_NAME"
output=`$MYSQL_CONNECT $database $DATABASE_SERVER $DATABASE_PORT $DATABASE_USER $DATABASE_PASSWORD`
result=$?
if [ $result -ne 0 ]; then
    echo -e "ERROR\n$output"
    return 1
fi
mysql_version=$output
output=""
echo "OK"
add_to_list_var DATABASE CHECKED_MODULES
return 0
}
# END OF check_DATABASE_config

# FUNCTION: check_PARSER_config
# Description: check if PARSER module configuration is valid
# Parameters: none
# Variables set: none
check_PARSER_config()
{
in_list PARSER $CHECKED_MODULES && return 0
echo -n "Testing PARSER configuration..."
if [ "$PARSER_ALLOWED_HOSTS" = "" ]; then
    echo -e "ERROR\nPARSER_ALLOWED_HOSTS is empty."
    return 1
fi
admin_selected=false
in_list ADMIN_INTERFACE $SELECTED_MODULES && admin_selected=true
if [ "$admin_selected" = "false" ] && ( [ "$PARSER_ALLOWED_HOSTS" = "localhost" ] || [ "$PARSER_ALLOWED_HOSTS" = "127.0.0.1" ] ); then
    echo -e "ERROR\nADMIN_INTERFACE module is not selected for local install but allowed host is localhost."
    return 1
fi
if [ "$admin_selected" = "true" ]; then
    if ! in_list localhost $PARSER_ALLOWED_HOSTS && ! in_list "127.0.0.1" $PARSER_ALLOWED_HOSTS; then
	echo -e "ERROR\nALLOWED_HOST must contain localhost (127.0.0.1)!"
	return 1
    fi
fi
check4_apache $1
[ $? -ne 0 ] && return 1
if [ "$PARSER_USER" != "$APACHE_USER" ] || [ "$PARSER_GROUP" != "$APACHE_GROUP" ]; then
    echo -e "ERROR\nParser process user/group is not the same as apache user/group."
    return 1
fi
add_to_list_var PARSER CHECKED_MODULES
echo "OK"
return 0
}
# END OF check_PARSER_config

# FUNCTION: check_EVENT_HANDLERS_config
# Description: check if EVENT_HANDLERS configuration is valid
# Parameters: none
# Variables set:
#	output - output error message (if any)
check_EVENT_HANDLERS_config()
{
in_list EVENT_HANDLERS $CHECKED_MODULES && return 0
echo -n "Testing EVENT_HANDLERS configuration..."
user_name=`id -u -n`
host_name=`hostname`
user_email="$user_name@$host_name"
output=`$SMTP_WRAPPER $user_email -r $user_email -s $EVENT_HANDLERS_SMTP_SERVER --test`
result=$?
if [ $result -ne 0 ]; then
    echo -e "ERROR\n$output"
    return 1
fi
output=""
add_to_list_var EVENT_HANDLERS CHECKED_MODULES
echo "OK"
return 0
}
# END OF check_EVENT_HANDLERS_config

# FUNCTION: check_SEARCH_ENGINE_config
# Description: check if SEARCH_ENGINE configuration is valid
# Parameters: none
# Variables set: none
check_SEARCH_ENGINE_config()
{
add_to_list_var SEARCH_ENGINE CHECKED_MODULES
echo "Nothing to test for SEARCH_ENGINE configuration"
return 0
}
# END OF check_SEARCH_ENGINE_config

# FUNCTION: check_ADMIN_INTERFACE_config
# Description: check if ADMIN_INTERFACE configuration is valid
# Parameters: none
# Variables set: none
check_ADMIN_INTERFACE_config()
{
if ! in_list PARSER $SELECTED_MODULES; then
    echo "Nothing to test for ADMIN_INTERFACE configuration"
    add_to_list_var ADMIN_INTERFACE CHECKED_MODULES
    return 0
fi
echo -n "Testing ADMIN_INTERFACE configuration..."
modules_conf --set PARSER > /dev/null
if [ $PARSER_PORT -ne $ADMIN_INTERFACE_PARSER_PORT ]; then
    echo -e "ERROR\nParser port on ADMIN_INTERFACE and PARSER modules must be the same!"
    return 1
fi
if [ "$ADMIN_INTERFACE_PARSER_IP" != "localhost" ] && [ "$ADMIN_INTERFACE_PARSER_IP" != "127.0.0.1" ]; then
    echo -e "ERROR\nPARSER_IP must be localhost (127.0.0.1)!"
    return 1
fi
echo "OK"
add_to_list_var ADMIN_INTERFACE CHECKED_MODULES
return 0
}
# END OF check_ADMIN_INTERFACE_config

# FUNCTION: check_install_config
# Description: check if install configuration is valid
# Parameters:
#	$1=--upgrade - configure for upgrade
# Variables set: none
check_install_config()
{
ic_upgrade=false
while [ "$1" != "" ]; do
    case $1 in
    --upgrade) ic_upgrade=true ;;
    --define_start_env) ic_upgrade=true ;;
    esac
    shift 1
done
echo -n "Testing install configuration..."
if [ ! -f $CAMPSITE_REGISTER ] || [ "$ic_upgrade" = "true" ]; then
    echo "OK"
    return 0
fi
grep -w $APP_NAME $CAMPSITE_REGISTER &> /dev/null
result=$?
if [ $result -eq 0 ]; then
    echo -e "ERROR\nThe name is already used by another installation of campsite. Use --upgrade parameter for upgrade."
    return 1
fi
echo "OK"
return 0
}
# END OF check_install_config

# FUNCTION: do_module_full_config
# Description: perform a full configuration of module
# Parameters:
#	$1 - module to perform configuration for
#	--upgrade - configure for upgrade
# Variables set: none
do_module_full_config()
{
fc_mod=$1
shift 1
mfc_upgrade=""
define_start_env=false
while [ "$1" != "" ]; do
    case $1 in
    --upgrade) mfc_upgrade=--upgrade ;;
    --define_start_env) define_start_env=true ;;
    esac
    shift 1
done
validate_module $fc_mod || return 1
is_configured $fc_mod && return 0
preconf_mod=`preconf_modules $fc_mod`
[ $? -ne 0 ] && echo $preconf_mod && return 1
if [ "$preconf_mod" != "" ]; then
    for fc_pmod in $preconf_mod; do
	if ! in_list $fc_pmod $CHECKED_MODULES; then
	    check_module_deps $fc_pmod && modules_conf --set $fc_pmod && prepare_${fc_pmod}_env
	    [ $? -ne 0 ] && return 1
	    if [ "$define_start_env" = "false" ]; then
		check_${fc_pmod}_config $mfc_upgrade
		[ $? -ne 0 ] && return 1
	    fi
	fi
    done
fi
check_module_deps $fc_mod && modules_conf --set $fc_mod && prepare_${fc_mod}_env
[ $? -ne 0 ] && return 1
if [ "$define_start_env" = "false" ]; then
    check_${fc_mod}_config $mfc_upgrade
    [ $? -ne 0 ] && return 1
fi
set_configured $fc_mod
return 0
}
# END OF do_module_full_config

# FUNCTION: do_install_full_config
# Description: perform a full install configuration
# Parameters: none
# Variables set: none
do_install_full_config()
{
[ "$INSTALL_CONFIGURED" = "yes" ] && return 0
prepare_install_env && check_install_deps && install_conf --set && check_install_config $*
result=$?
[ $result -eq 0 ] && export INSTALL_CONFIGURED=yes
return $result
}
# END OF do_install_full_config


###########################################################
## Functions for writing the configuation files
###########################################################

# FUNCTION: set_module_config
# Description: write the configuration for selected module
# Parameters:
#	$1 - selected module
# Variables set:
#	output - output error message (if any)
set_module_config()
{
module=$1
output=`validate_module "$module" --config`
if [ $? -ne 0 ]; then
    echo "$output"
    return 1
fi
tmp_file=".$$.modules.conf"
> $tmp_file
state=init
while true; do
    read line
    if [ "$line" = "" ]; then
	break
    fi
    case $state in
    init)
	module_name=""
	inner_state=init
	for w in $line; do
	    case $inner_state in
	    init)
		if [ "$w" = "[" ]; then
		    state=read_module_name
		    inner_state=read_module_name
		else
		    echo $line >> $tmp_file
		    break
		fi ;;
	    read_module_name)
		module_name=$w
		echo -e "[\n$module_name" >> $tmp_file
		state=read_attr
		break ;;
	    *)
		echo "Internal error; invalid state $inner_state"
		rm -f $tmp_file
		exit 1 ;;
	    esac
	done ;;
    read_module_name)
	for w in $line; do
	    module_name=$w
	    echo -e "[\n$module_name" >> $tmp_file
	    state=read_attr
            break
	done ;;
    read_attr)
	i=1
	fw=""
	for w in $line; do
	    if [ $i -eq 1 ]; then
		fw=$w
	    fi
	    if [ "$w" = "]" ]; then
		state=init
		break
	    fi
	    let i=$i+1
	done
	if [ "$module_name" = "$module" ] && [ "$fw" != "]" ]; then
	    attr_name=""
	    attr_val=""
	    attr_desc=""
	    inner_state=attr_name
	    for w in $line; do
		case $inner_state in
		attr_name)
		    attr_name=$w
		    inner_state=attr_val ;;
		attr_val)
		    if [ "$w" != "{" ]; then
			attr_val="$attr_val $w"
		    else
			inner_state=attr_desc
		    fi ;;
		attr_desc)
		    if [ "$w" = "}" ]; then
			break
		    elif [ "$w" != "{" ]; then
			attr_desc="$attr_desc $w"
		    fi ;;
		*)
		    echo "Internal error; invalid state $inner_state"
		    rm -f $tmp_file
		    exit 1 ;;
		esac
	    done
	    real_attr_name="${module_name}_$attr_name"
	    echo -e "$attr_name ${!real_attr_name}\t{$attr_desc }" >> $tmp_file
	fi
	if [ "$module_name" != "$module" ] && [ "$fw" != "]" ]; then
	    echo "$line" >> $tmp_file
	fi
	if [ "$state" = "init" ]; then
	    echo "]" >> $tmp_file
	fi ;;
    *)
	echo "Internal error; invalid state $state"
	rm -f $tmp_file
	exit 1 ;;
    esac
done
cp -f $tmp_file ${INSTALL_CONF}/.modules.conf
rm -f $tmp_file
set_configured $module_name
return 0
}
# END OF set_module_config

# FUNCTION: set_install_config
# Description: write the install configuration
# Parameters: none
# Variables set: none
set_install_config()
{
tmp_file=".$$.install.conf"
> $tmp_file
state=init
while true; do
    read line
    case $state in
    init)
	for w in $line; do
	    if [ "$w" = "[" ]; then
		echo "[" >> $tmp_file
		state=read_attr
	    fi
	done
	[ "$state" = "init" ] && echo "$line" >> $tmp_file
	;;
    read_attr)
	i=1
	fw=""
	for w in $line; do
	    if [ $i -eq 1 ]; then
		fw=$w
	    fi
	    if [ "$w" = "]" ]; then
		state=end
		break
	    fi
	    let i=$i+1
	done
	if [ "$fw" != "]" ]; then
	    attr_name=""
	    attr_val=""
	    attr_desc=""
	    inner_state=attr_name
	    for w in $line; do
		case $inner_state in
		attr_name)
		    attr_name=$w
		    inner_state=attr_val ;;
		attr_val)
		    if [ "$w" != "{" ]; then
			attr_val="$attr_val $w"
		    else
			inner_state=attr_desc
		    fi ;;
		attr_desc)
		    if [ "$w" = "}" ]; then
			break
		    elif [ "$w" != "{" ]; then
			attr_desc="$attr_desc $w"
		    fi ;;
		*)
		    echo "Internal error; invalid state $inner_state"
		    rm -f $tmp_file
		    exit 1 ;;
		esac
	    done
	    echo -e "$attr_name ${!attr_name}\t{$attr_desc }" >> $tmp_file
	fi
	if [ "$state" = "end" ]; then
	    echo "]" >> $tmp_file
	fi ;;
    end)
	echo "$line" >> $tmp_file
        break
	;;
    *)
	echo "Internal error; invalid state $state"
	rm -f $tmp_file
	exit 1 ;;
    esac
done
cp -f $tmp_file ${INSTALL_CONF}/.inst.conf
rm -f $tmp_file
INSTALL_CONFIGURED=yes
return 0
}
# END OF set_install_config

###########################################################
## Functions for user interface
###########################################################

# FUNCTION: read_module_conf
# Description: read the configuration of selected module from console
# Parameters:
#	$1 - selected module
# Variables set:
#	output - output error message (if any)
read_module_conf()
{
module=$1
output=`validate_module "$module" --config`
if [ $? -ne 0 ]; then
    echo "$output"
    return 1
fi
attr_name_list="`modules_conf $module | cut -f 1 -d "="`"
for attr_name in $attr_name_list; do
    al="`modules_conf $module | grep -w $attr_name`"
    attr_val="`echo $al | cut -f 2 -d "=" | cut -f 1 -d "#"`"
    attr_val="`echo $attr_val`"
    attr_desc="`echo $al | cut -f 2 -d "#"`"
    export $attr_name="$attr_val"
    read_string $attr_name "$attr_val" "$attr_desc"
done
return 0
}
# END OF read_module_conf

# FUNCTION: read_install_conf
# Description: read the install configuration from console
# Parameters: none
# Variables set: none
read_install_conf()
{
attr_list=`install_conf | cut -f 1 -d "#"`
attr_name_list=""
for a in $attr_list; do
    attr_name=`echo $a | cut -f 1 -d "="`
    attr_name_list="$attr_name_list $attr_name"
    attr_val=`echo $a | cut -f 2 -d "="`
    export $a
    read_string $attr_name "$attr_val" "`install_conf | grep -w ^$attr_name | cut -f 2 -d "#"`"
done
return 0
}
# END OF read_install_conf

# FUNCTION: module_config_menu
# Description: prints a menu for configuring the selected module
# Parameters:
#	$1 - selected module
# Variables set:
#	output - output error message (if any)
module_config_menu()
{
module=$1
output=`validate_module "$module" --config`
if [ $? -ne 0 ]; then
    echo "$output"
    return 1
fi
clear
echo "Current $module configuration:"
modules_conf $module
echo -e "\nSelect\t1 - to modify configuration\n\t0 - to exit"
return 0
}
# END OF module_config_menu

# FUNCTION: install_config_menu
# Description: prints a menu for install configuration
# Parameters: none
# Variables set: none
install_config_menu()
{
clear
echo "Current install configuration:"
install_conf $module
echo -e "\nSelect\t1 - to modify configuration\n\t0 - to exit"
return 0
}
# END OF install_config_menu

# FUNCTION: configure_module
# Description: prints a menu for module configuration and performs
#	according to input
# Parameters:
#	$1 - selected module
# Variables set:
#	output - output error message (if any)
configure_module()
{
module=$1
shift 1
output=`validate_module "$module" --config`
if [ $? -ne 0 ]; then
    echo "$output"
    return 1
fi
module_check=$1
shift 1
message=""
while true; do
    module_config_menu "$module"
    echo $message
    echo -n -e "Option: "
    read option
    case $option in
    1)
	message=""
	while true; do
	    read_module_conf "$module"
            result=0
	    if [ "$module_check" != "" ]; then
		$module_check $*
		result=$?
	    fi
	    if [ $result -ne 0 ]; then
		choice_yn "Invalid $module module configuration. Try again?" y
		if [ "$choice" = "N" ]; then
		    break
		fi
	    else
		choice_yn "Commit changes?" y
		if [ "$choice" = "Y" ]; then
		    output=`set_module_config "$module" < ${INSTALL_CONF}/.modules.conf`
		    if [ $? -ne 0 ]; then
			message=$output
		    fi
		fi
		break
	    fi
	done ;;
    0)
	clear
	message=""
	return 0 ;;
    *)
	message="Invalid option $option" ;;
    esac
done
return 0
}
# END OF configure_module

# FUNCTION: configure_install
# Description: prints a menu for install configuration and performs
#	according to input
# Parameters: none
# Variables set: none
configure_install()
{
message=""
while true; do
    install_config_menu
    echo $message
    echo -n -e "Option: "
    read option
    case $option in
    1)
	message=""
	while true; do
	    read_install_conf
	    check_install_config
	    result=$?
	    if [ $result -ne 0 ]; then
		choice_yn "Invalid install configuration. Try again?" y
		if [ "$choice" = "N" ]; then
		    break
		fi
	    else
		choice_yn "Commit changes?" y
		if [ "$choice" = "Y" ]; then
		    output=`set_install_config < ${INSTALL_CONF}/.inst.conf`
		    if [ $? -ne 0 ]; then
			message=$output
		    fi
		fi
		break
	    fi
	done ;;
    0)
	clear
	message=""
	return 0 ;;
    *)
	message="Invalid option $option" ;;
    esac
done
return 0
}
# END OF configure_install
